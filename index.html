<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic Christmas - Final Clean</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100%; height: 100vh; display: block; }
        
        /* UI Center */
        #ui-layer {
            position: absolute; bottom: 30px; width: 100%;
            text-align: center; pointer-events: none; z-index: 100;
        }
        
        /* Guide text */
        .guide { 
            color: rgba(255, 255, 255, 0.6); 
            font-size: 13px; 
            margin-bottom: 20px; 
            text-shadow: 0 2px 4px black;
        }

        button {
            pointer-events: auto; cursor: pointer;
            background: linear-gradient(to bottom, #D32F2F, #8B0000); 
            color: #FFF; border: 2px solid #FFD700;
            padding: 15px 50px; border-radius: 30px; 
            font-weight: 800; font-size: 16px;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.6);
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        /* Camera Preview */
        #camera-preview {
            position: absolute; top: 15px; right: 15px;
            width: 120px; height: 90px;
            border: 2px solid rgba(255,0,0,0.5); 
            transform: scaleX(-1); opacity: 0.6; border-radius: 8px;
        }
        
        #copyright {
            position: absolute;
            bottom: 10px;
            right: 15px;
            color: rgba(255, 255, 255, 0.3);
            font-size: 12px;
            z-index: 100;
            font-family: sans-serif;
            pointer-events: none;
            font-style: italic;
        }
        
        /* Debug panel */
        #debug {
            position: absolute;
            top: 15px;
            left: 15px;
            color: #0f0;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            font-size: 12px;
            font-family: monospace;
            z-index: 200;
            border-radius: 5px;
            display: none;
        }

        #error-log { display: none; position: absolute; top: 0; left: 0; color: red; background: rgba(0,0,0,0.8); z-index: 999; padding: 10px; }
    </style>
</head>
<body>
    <div id="error-log"></div>
    <div id="debug"></div>
    
    <!-- UI -->
    <div id="ui-layer">
        <div class="guide">
            üñê <b>Open:</b> Explode &nbsp;|&nbsp; ü´∂ <b>Heart:</b> Love &nbsp;|&nbsp; ‚úä <b>Fist:</b> Tree &nbsp;|&nbsp; üëÜ <b>1 Ng√≥n</b> &nbsp;|&nbsp; ‚úåÔ∏è <b>2 Ng√≥n</b>
        </div>
        <button id="btnStart" onclick="startSystem()">START MAGIC</button>
    </div>

    <div id="copyright">¬© by nguyencongtuyenlp</div>

    <div id="canvas-container"></div>
    <video class="input_video" style="display:none"></video>
    <canvas id="camera-preview"></canvas>

    <script>
        // ==========================================
        // 1. RESOURCES CONFIG
        // ==========================================
        const MUSIC_URL = "./audio.mp3";
        let bgMusic = new Audio(MUSIC_URL);
        bgMusic.loop = true; bgMusic.volume = 1.0;

        const loader = new THREE.TextureLoader();
        // TH√äM ·∫¢NH M·ªöI: Th√™m ƒë∆∞·ªùng d·∫´n v√†o m·∫£ng n√†y
        const photoFiles = ['./image1.jpeg', './image2.jpeg', './image3.jpg', './image4.jpg', './image5.jpg'];
        const photoTextures = [];
        photoFiles.forEach((f, i) => photoTextures[i] = loader.load(f));

        function createCustomTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const cx = 64, cy = 64;

            if (type === 'gold_glow') {
                const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 40);
                grd.addColorStop(0, '#FFFFFF'); 
                grd.addColorStop(0.2, '#FFFFE0'); 
                grd.addColorStop(0.5, '#FFD700');
                grd.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grd; ctx.fillRect(0,0,128,128);

            } else if (type === 'red_light') {
                const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 50);
                grd.addColorStop(0, '#FFAAAA'); 
                grd.addColorStop(0.3, '#FF0000'); 
                grd.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grd; ctx.fillRect(0,0,128,128);

            } else if (type === 'gift_red') {
                ctx.fillStyle = '#D32F2F'; ctx.fillRect(20, 20, 88, 88);
                ctx.fillStyle = '#FFD700'; ctx.fillRect(54, 20, 20, 88); ctx.fillRect(20, 54, 88, 20);
                ctx.strokeStyle = "rgba(0,0,0,0.3)"; ctx.lineWidth=2; ctx.strokeRect(20,20,88,88);
            }
            return new THREE.CanvasTexture(canvas);
        }

        const textures = {
            gold: createCustomTexture('gold_glow'),
            red: createCustomTexture('red_light'),
            gift: createCustomTexture('gift_red')
        };

        // ==========================================
        // 2. SYSTEM CONFIG
        // ==========================================
        const CONFIG = {
            goldCount: 2000,
            redCount: 300,
            giftCount: 150,
            explodeRadius: 65,  
            photoOrbitRadius: 25,
            treeHeight: 70,
            treeBaseRadius: 35
        };
        
        // T·ª± ƒë·ªông t√≠nh s·ªë l∆∞·ª£ng ·∫£nh
        CONFIG.photoCount = photoFiles.length;

        let scene, camera, renderer;
        let groupGold, groupRed, groupGift; 
        let photoMeshes = [];    
        let titleMesh, starMesh, loveMesh, oneFingerMesh, twoFingersMesh;
        let santaMesh, reindeerMeshes = [];  // √îng gi√† Noel v√† tu·∫ßn l·ªôc
        let angelMeshes = [];  // Thi√™n th·∫ßn
        let catMesh;  // M√®o cute
        let bgStars;  // Sao l·∫•p l√°nh background
        
        let state = 'TREE'; 
        let selectedIndex = 0;
        let handX = 0.5;

        // ==========================================
        // 3. THREE.JS SYSTEM
        // ==========================================
        function init3D() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.002);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            groupGold = createParticleSystem('gold', CONFIG.goldCount, 2.0);
            groupRed = createParticleSystem('red', CONFIG.redCount, 3.5); 
            groupGift = createParticleSystem('gift', CONFIG.giftCount, 3.0); 

            createPhotos();
            createDecorations();
            createSantaAndReindeer();
            createBackgroundStars();
            createAngelsAndCat();
            animate();
        }

        function createParticleSystem(type, count, size) {
            const pPositions = [];
            const pExplodeTargets = [];
            const pTreeTargets = [];
            const pHeartTargets = [];
            const sizes = []; 
            const phases = []; 
            
            for(let i=0; i<count; i++) {
                // --- TREE ---
                const h = Math.random() * CONFIG.treeHeight; 
                const y = h - CONFIG.treeHeight / 2;
                let radiusRatio = (type === 'gold') ? Math.sqrt(Math.random()) : 0.9 + Math.random()*0.1;
                const maxR = (1 - (h / CONFIG.treeHeight)) * CONFIG.treeBaseRadius;
                const r = maxR * radiusRatio; 
                const theta = Math.random() * Math.PI * 2;
                pTreeTargets.push(r * Math.cos(theta), y, r * Math.sin(theta));

                // --- EXPLODE ---
                const u = Math.random();
                const v = Math.random();
                const phi = Math.acos(2 * v - 1);
                const lam = 2 * Math.PI * u;
                let radMult = (type === 'gift') ? 1.2 : 1.0;
                const rad = CONFIG.explodeRadius * Math.cbrt(Math.random()) * radMult;
                pExplodeTargets.push(rad * Math.sin(phi) * Math.cos(lam), rad * Math.sin(phi) * Math.sin(lam), rad * Math.cos(phi));

                // --- SOFT HEART ---
                const tHeart = Math.random() * Math.PI * 2;
                let hx = 16 * Math.pow(Math.sin(tHeart), 3);
                let hy = 13 * Math.cos(tHeart) - 5 * Math.cos(2*tHeart) - 2 * Math.cos(3*tHeart) - Math.cos(4*tHeart);
                
                const rFill = Math.pow(Math.random(), 0.3);
                hx *= rFill; hy *= rFill;
                let hz = (Math.random() - 0.5) * 8 * rFill; 
                
                const noise = 1.0;
                hx += (Math.random() - 0.5) * noise;
                hy += (Math.random() - 0.5) * noise;
                hz += (Math.random() - 0.5) * noise;

                const scaleH = 2.2;
                pHeartTargets.push(hx * scaleH, hy * scaleH + 5, hz); 

                // --- INIT ---
                pPositions.push(pTreeTargets[i*3], pTreeTargets[i*3+1], pTreeTargets[i*3+2]);
                sizes.push(size);
                phases.push(Math.random() * Math.PI * 2);
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pPositions, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            
            // Init colors
            const colors = new Float32Array(count * 3);
            const baseColor = new THREE.Color();
            if(type === 'gold') baseColor.setHex(0xFFD700);
            else if(type === 'red') baseColor.setHex(0xFF0000);
            else baseColor.setHex(0xFFFFFF);

            for(let i=0; i<count; i++) {
                colors[i*3] = baseColor.r;
                colors[i*3+1] = baseColor.g;
                colors[i*3+2] = baseColor.b;
            }
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            geo.userData = { 
                tree: pTreeTargets, explode: pExplodeTargets, heart: pHeartTargets, 
                phases: phases, baseColor: baseColor, baseSize: size
            };

            const mat = new THREE.PointsMaterial({
                size: size,
                map: textures[type],
                transparent: true, opacity: 1.0,
                vertexColors: true, 
                blending: (type === 'gift') ? THREE.NormalBlending : THREE.AdditiveBlending, 
                depthWrite: false,
                sizeAttenuation: true
            });

            const points = new THREE.Points(geo, mat);
            scene.add(points);
            return points;
        }

        function createPhotos() {
            const geo = new THREE.PlaneGeometry(8, 8);
            const borderGeo = new THREE.PlaneGeometry(9, 9); 
            const borderMat = new THREE.MeshBasicMaterial({ color: 0xFFD700 }); 

            for(let i=0; i<CONFIG.photoCount; i++) {
                const mat = new THREE.MeshBasicMaterial({ map: photoTextures[i], side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geo, mat);
                const border = new THREE.Mesh(borderGeo, borderMat);
                border.position.z = -0.1; 
                mesh.add(border);
                mesh.visible = false; mesh.scale.set(0,0,0);
                scene.add(mesh);
                photoMeshes.push(mesh);
            }
        }

        function createDecorations() {
            // MERRY CHRISTMAS
            const canvas = document.createElement('canvas');
            canvas.width = 2048; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold italic 70px "Times New Roman"';
            ctx.fillStyle = '#FFD700'; ctx.textAlign = 'center';
            ctx.shadowColor = "#FF0000"; ctx.shadowBlur = 40; 
            ctx.fillText("Merry Christmas to the love of my life‚ù§Ô∏è", 1024, 130);
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, blending: THREE.AdditiveBlending });
            titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(100, 15), mat);
            titleMesh.position.set(0, 50, 0);
            scene.add(titleMesh);

            // STAR
            const starCanvas = document.createElement('canvas');
            starCanvas.width = 128; starCanvas.height = 128;
            const sCtx = starCanvas.getContext('2d');
            sCtx.fillStyle = "#FFFF00"; sCtx.shadowColor="#FFF"; sCtx.shadowBlur=20;
            sCtx.beginPath();
            const cx=64, cy=64, outer=50, inner=20;
            for(let i=0; i<5; i++){
                sCtx.lineTo(cx + Math.cos((18+i*72)/180*Math.PI)*outer, cy - Math.sin((18+i*72)/180*Math.PI)*outer);
                sCtx.lineTo(cx + Math.cos((54+i*72)/180*Math.PI)*inner, cy - Math.sin((54+i*72)/180*Math.PI)*inner);
            }
            sCtx.closePath(); sCtx.fill();
            const starTex = new THREE.CanvasTexture(starCanvas);
            const starMat = new THREE.MeshBasicMaterial({ map: starTex, transparent: true, blending: THREE.AdditiveBlending });
            starMesh = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), starMat);
            starMesh.position.set(0, CONFIG.treeHeight/2 + 2, 0);
            scene.add(starMesh);

            // LOVE TEXT (HEART gesture)
            const loveCanvas = document.createElement('canvas');
            loveCanvas.width = 2048; loveCanvas.height = 256;
            const lCtx = loveCanvas.getContext('2d');
            lCtx.font = 'bold 70px "Segoe UI", sans-serif';
            lCtx.fillStyle = '#FF69B4'; lCtx.textAlign = 'center';
            lCtx.shadowColor = "#FF1493"; lCtx.shadowBlur = 40; 
            lCtx.fillText("CH√öC B√â TRANG GI√ÅNG SINH VUI V·∫∫ B√äN ANH!", 1024, 130);
            const loveTex = new THREE.CanvasTexture(loveCanvas);
            const loveMat = new THREE.MeshBasicMaterial({ map: loveTex, transparent: true, blending: THREE.AdditiveBlending });
            loveMesh = new THREE.Mesh(new THREE.PlaneGeometry(100, 18), loveMat);
            loveMesh.position.set(0, 0, 20);
            loveMesh.visible = false;
            scene.add(loveMesh);

            // TEXT CHO 1 NG√ìN TAY
            const oneFingerCanvas = document.createElement('canvas');
            oneFingerCanvas.width = 2048; oneFingerCanvas.height = 256;
            const oCtx = oneFingerCanvas.getContext('2d');
            oCtx.font = 'bold 65px "Segoe UI", sans-serif';
            oCtx.fillStyle = '#FFD700'; oCtx.textAlign = 'center';
            oCtx.shadowColor = "#FF6B00"; oCtx.shadowBlur = 40; 
            oCtx.fillText("ƒê√™m 24-12 nay ƒëi l·ªÖ nh√† th·ªù Th√°i H√† em nha!", 1024, 130);
            const oneFingerTex = new THREE.CanvasTexture(oneFingerCanvas);
            const oneFingerMat = new THREE.MeshBasicMaterial({ map: oneFingerTex, transparent: true, blending: THREE.AdditiveBlending });
            oneFingerMesh = new THREE.Mesh(new THREE.PlaneGeometry(100, 18), oneFingerMat);
            oneFingerMesh.position.set(0, 0, 20);
            oneFingerMesh.visible = false;
            scene.add(oneFingerMesh);

            // TEXT CHO 2 NG√ìN TAY
            const twoFingersCanvas = document.createElement('canvas');
            twoFingersCanvas.width = 2048; twoFingersCanvas.height = 256;
            const tCtx = twoFingersCanvas.getContext('2d');
            tCtx.font = 'bold 75px "Segoe UI", sans-serif';
            tCtx.fillStyle = '#FF69B4'; tCtx.textAlign = 'center';
            tCtx.shadowColor = "#FF1493"; tCtx.shadowBlur = 40; 
            tCtx.fillText("Em l√† ph√©p m√†u Gi√°ng Sinh c·ªßa anh‚ù§Ô∏è", 1024, 130);
            const twoFingersTex = new THREE.CanvasTexture(twoFingersCanvas);
            const twoFingersMat = new THREE.MeshBasicMaterial({ map: twoFingersTex, transparent: true, blending: THREE.AdditiveBlending });
            twoFingersMesh = new THREE.Mesh(new THREE.PlaneGeometry(100, 18), twoFingersMat);
            twoFingersMesh.position.set(0, 0, 20);
            twoFingersMesh.visible = false;
            scene.add(twoFingersMesh);
        }

        function createSantaAndReindeer() {
            // ==========================================
            // T·∫†O √îNG GI√Ä NOEL
            // ==========================================
            const santaCanvas = document.createElement('canvas');
            santaCanvas.width = 128; santaCanvas.height = 128;
            const sCtx = santaCanvas.getContext('2d');
            
            // Th√¢n (√°o ƒë·ªè)
            sCtx.fillStyle = '#D32F2F';
            sCtx.beginPath();
            sCtx.arc(64, 75, 35, 0, Math.PI * 2);
            sCtx.fill();
            
            // M·∫∑t
            sCtx.fillStyle = '#FFDBAC';
            sCtx.beginPath();
            sCtx.arc(64, 40, 25, 0, Math.PI * 2);
            sCtx.fill();
            
            // R√¢u tr·∫Øng
            sCtx.fillStyle = '#FFFFFF';
            sCtx.beginPath();
            sCtx.arc(64, 55, 20, 0, Math.PI);
            sCtx.fill();
            
            // M≈© ƒë·ªè
            sCtx.fillStyle = '#D32F2F';
            sCtx.beginPath();
            sCtx.moveTo(35, 35);
            sCtx.lineTo(64, 5);
            sCtx.lineTo(93, 35);
            sCtx.closePath();
            sCtx.fill();
            
            // Pompom m≈©
            sCtx.fillStyle = '#FFFFFF';
            sCtx.beginPath();
            sCtx.arc(64, 8, 8, 0, Math.PI * 2);
            sCtx.fill();
            
            // Vi·ªÅn m≈© tr·∫Øng
            sCtx.fillStyle = '#FFFFFF';
            sCtx.fillRect(35, 30, 58, 10);
            
            // M·∫Øt
            sCtx.fillStyle = '#000000';
            sCtx.beginPath();
            sCtx.arc(54, 38, 3, 0, Math.PI * 2);
            sCtx.arc(74, 38, 3, 0, Math.PI * 2);
            sCtx.fill();
            
            // Th·∫Øt l∆∞ng
            sCtx.fillStyle = '#000000';
            sCtx.fillRect(45, 70, 38, 8);
            sCtx.fillStyle = '#FFD700';
            sCtx.fillRect(58, 68, 12, 12);
            
            const santaTex = new THREE.CanvasTexture(santaCanvas);
            const santaMat = new THREE.SpriteMaterial({ map: santaTex, transparent: true });
            santaMesh = new THREE.Sprite(santaMat);
            santaMesh.scale.set(12, 12, 1);
            scene.add(santaMesh);

            // ==========================================
            // T·∫†O TU·∫¶N L·ªòC (3 con)
            // ==========================================
            for(let i = 0; i < 3; i++) {
                const reindeerCanvas = document.createElement('canvas');
                reindeerCanvas.width = 128; reindeerCanvas.height = 128;
                const rCtx = reindeerCanvas.getContext('2d');
                
                // Th√¢n (n√¢u)
                rCtx.fillStyle = '#8B4513';
                rCtx.beginPath();
                rCtx.ellipse(64, 75, 30, 20, 0, 0, Math.PI * 2);
                rCtx.fill();
                
                // ƒê·∫ßu
                rCtx.fillStyle = '#A0522D';
                rCtx.beginPath();
                rCtx.arc(64, 45, 20, 0, Math.PI * 2);
                rCtx.fill();
                
                // M≈©i ƒë·ªè (Rudolph!)
                rCtx.fillStyle = '#FF0000';
                rCtx.beginPath();
                rCtx.arc(64, 55, 8, 0, Math.PI * 2);
                rCtx.fill();
                rCtx.shadowColor = "#FF0000";
                rCtx.shadowBlur = 15;
                rCtx.fill();
                rCtx.shadowBlur = 0;
                
                // M·∫Øt
                rCtx.fillStyle = '#000000';
                rCtx.beginPath();
                rCtx.arc(54, 42, 4, 0, Math.PI * 2);
                rCtx.arc(74, 42, 4, 0, Math.PI * 2);
                rCtx.fill();
                
                // S·ª´ng tr√°i
                rCtx.strokeStyle = '#654321';
                rCtx.lineWidth = 4;
                rCtx.beginPath();
                rCtx.moveTo(45, 35);
                rCtx.lineTo(35, 15);
                rCtx.lineTo(25, 20);
                rCtx.moveTo(35, 15);
                rCtx.lineTo(40, 5);
                rCtx.stroke();
                
                // S·ª´ng ph·∫£i
                rCtx.beginPath();
                rCtx.moveTo(83, 35);
                rCtx.lineTo(93, 15);
                rCtx.lineTo(103, 20);
                rCtx.moveTo(93, 15);
                rCtx.lineTo(88, 5);
                rCtx.stroke();
                
                // Ch√¢n
                rCtx.fillStyle = '#654321';
                rCtx.fillRect(45, 90, 6, 20);
                rCtx.fillRect(55, 90, 6, 20);
                rCtx.fillRect(67, 90, 6, 20);
                rCtx.fillRect(77, 90, 6, 20);
                
                const reindeerTex = new THREE.CanvasTexture(reindeerCanvas);
                const reindeerMat = new THREE.SpriteMaterial({ map: reindeerTex, transparent: true });
                const reindeerMesh = new THREE.Sprite(reindeerMat);
                reindeerMesh.scale.set(10, 10, 1);
                scene.add(reindeerMesh);
                reindeerMeshes.push(reindeerMesh);
            }
        }

        function createBackgroundStars() {
            // ==========================================
            // SAO L·∫§P L√ÅNH ·ªû BACKGROUND
            // ==========================================
            const starCount = 500;
            const positions = [];
            const sizes = [];
            const phases = [];
            
            for(let i = 0; i < starCount; i++) {
                // Ph√¢n b·ªë sao tr√™n m·ªôt h√¨nh c·∫ßu l·ªõn xung quanh scene
                const radius = 150 + Math.random() * 100;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                positions.push(
                    radius * Math.sin(phi) * Math.cos(theta),
                    radius * Math.sin(phi) * Math.sin(theta) - 20,
                    radius * Math.cos(phi)
                );
                sizes.push(0.5 + Math.random() * 1.5);
                phases.push(Math.random() * Math.PI * 2);
            }
            
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geo.userData = { phases: phases };
            
            // T·∫°o texture sao s√°ng
            const starCanvas = document.createElement('canvas');
            starCanvas.width = 64; starCanvas.height = 64;
            const ctx = starCanvas.getContext('2d');
            const grd = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grd.addColorStop(0, '#FFFFFF');
            grd.addColorStop(0.2, '#FFFFCC');
            grd.addColorStop(0.5, '#FFFF99');
            grd.addColorStop(1, 'rgba(255,255,200,0)');
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, 64, 64);
            
            const starTex = new THREE.CanvasTexture(starCanvas);
            const mat = new THREE.PointsMaterial({
                size: 2,
                map: starTex,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            bgStars = new THREE.Points(geo, mat);
            scene.add(bgStars);
        }

        function createAngelsAndCat() {
            // ==========================================
            // T·∫†O THI√äN TH·∫¶N (2 con)
            // ==========================================
            for(let i = 0; i < 2; i++) {
                const angelCanvas = document.createElement('canvas');
                angelCanvas.width = 128; angelCanvas.height = 128;
                const aCtx = angelCanvas.getContext('2d');
                
                // V√°y/√Åo tr·∫Øng
                aCtx.fillStyle = '#FFFFFF';
                aCtx.beginPath();
                aCtx.moveTo(40, 50);
                aCtx.lineTo(64, 45);
                aCtx.lineTo(88, 50);
                aCtx.lineTo(95, 110);
                aCtx.lineTo(33, 110);
                aCtx.closePath();
                aCtx.fill();
                
                // M·∫∑t
                aCtx.fillStyle = '#FFDBAC';
                aCtx.beginPath();
                aCtx.arc(64, 35, 18, 0, Math.PI * 2);
                aCtx.fill();
                
                // T√≥c v√†ng
                aCtx.fillStyle = '#FFD700';
                aCtx.beginPath();
                aCtx.arc(64, 30, 18, Math.PI, Math.PI * 2);
                aCtx.fill();
                aCtx.fillRect(46, 25, 6, 20);
                aCtx.fillRect(76, 25, 6, 20);
                
                // V√≤ng h√†o quang
                aCtx.strokeStyle = '#FFD700';
                aCtx.lineWidth = 3;
                aCtx.shadowColor = "#FFD700";
                aCtx.shadowBlur = 15;
                aCtx.beginPath();
                aCtx.ellipse(64, 12, 15, 5, 0, 0, Math.PI * 2);
                aCtx.stroke();
                aCtx.shadowBlur = 0;
                
                // C√°nh tr√°i
                aCtx.fillStyle = 'rgba(255,255,255,0.8)';
                aCtx.beginPath();
                aCtx.ellipse(30, 55, 20, 35, -0.3, 0, Math.PI * 2);
                aCtx.fill();
                
                // C√°nh ph·∫£i
                aCtx.beginPath();
                aCtx.ellipse(98, 55, 20, 35, 0.3, 0, Math.PI * 2);
                aCtx.fill();
                
                // M·∫Øt
                aCtx.fillStyle = '#000000';
                aCtx.beginPath();
                aCtx.arc(57, 35, 2, 0, Math.PI * 2);
                aCtx.arc(71, 35, 2, 0, Math.PI * 2);
                aCtx.fill();
                
                // Mi·ªáng c∆∞·ªùi
                aCtx.strokeStyle = '#FF6B6B';
                aCtx.lineWidth = 2;
                aCtx.beginPath();
                aCtx.arc(64, 40, 6, 0.2, Math.PI - 0.2);
                aCtx.stroke();
                
                const angelTex = new THREE.CanvasTexture(angelCanvas);
                const angelMat = new THREE.SpriteMaterial({ map: angelTex, transparent: true });
                const angelMesh = new THREE.Sprite(angelMat);
                angelMesh.scale.set(10, 10, 1);
                scene.add(angelMesh);
                angelMeshes.push(angelMesh);
            }

            // ==========================================
            // T·∫†O M√àO CUTE ƒê·ªòI M≈® NOEL
            // ==========================================
            const catCanvas = document.createElement('canvas');
            catCanvas.width = 128; catCanvas.height = 128;
            const cCtx = catCanvas.getContext('2d');
            
            // Th√¢n m√®o (x√°m)
            cCtx.fillStyle = '#808080';
            cCtx.beginPath();
            cCtx.ellipse(64, 85, 25, 20, 0, 0, Math.PI * 2);
            cCtx.fill();
            
            // ƒê·∫ßu m√®o
            cCtx.fillStyle = '#A0A0A0';
            cCtx.beginPath();
            cCtx.arc(64, 50, 28, 0, Math.PI * 2);
            cCtx.fill();
            
            // Tai tr√°i
            cCtx.fillStyle = '#808080';
            cCtx.beginPath();
            cCtx.moveTo(40, 35);
            cCtx.lineTo(30, 10);
            cCtx.lineTo(50, 25);
            cCtx.closePath();
            cCtx.fill();
            // Trong tai
            cCtx.fillStyle = '#FFB6C1';
            cCtx.beginPath();
            cCtx.moveTo(42, 32);
            cCtx.lineTo(35, 15);
            cCtx.lineTo(48, 27);
            cCtx.closePath();
            cCtx.fill();
            
            // Tai ph·∫£i
            cCtx.fillStyle = '#808080';
            cCtx.beginPath();
            cCtx.moveTo(88, 35);
            cCtx.lineTo(98, 10);
            cCtx.lineTo(78, 25);
            cCtx.closePath();
            cCtx.fill();
            // Trong tai
            cCtx.fillStyle = '#FFB6C1';
            cCtx.beginPath();
            cCtx.moveTo(86, 32);
            cCtx.lineTo(93, 15);
            cCtx.lineTo(80, 27);
            cCtx.closePath();
            cCtx.fill();
            
            // M·∫Øt to tr√≤n cute
            cCtx.fillStyle = '#90EE90';
            cCtx.beginPath();
            cCtx.arc(52, 48, 10, 0, Math.PI * 2);
            cCtx.arc(76, 48, 10, 0, Math.PI * 2);
            cCtx.fill();
            // Con ng∆∞∆°i
            cCtx.fillStyle = '#000000';
            cCtx.beginPath();
            cCtx.ellipse(52, 48, 4, 8, 0, 0, Math.PI * 2);
            cCtx.ellipse(76, 48, 4, 8, 0, 0, Math.PI * 2);
            cCtx.fill();
            // ƒêi·ªÉm s√°ng m·∫Øt
            cCtx.fillStyle = '#FFFFFF';
            cCtx.beginPath();
            cCtx.arc(49, 45, 3, 0, Math.PI * 2);
            cCtx.arc(73, 45, 3, 0, Math.PI * 2);
            cCtx.fill();
            
            // M≈©i h·ªìng
            cCtx.fillStyle = '#FFB6C1';
            cCtx.beginPath();
            cCtx.moveTo(64, 58);
            cCtx.lineTo(58, 65);
            cCtx.lineTo(70, 65);
            cCtx.closePath();
            cCtx.fill();
            
            // Mi·ªáng
            cCtx.strokeStyle = '#666666';
            cCtx.lineWidth = 2;
            cCtx.beginPath();
            cCtx.moveTo(64, 65);
            cCtx.lineTo(64, 72);
            cCtx.moveTo(58, 72);
            cCtx.quadraticCurveTo(64, 78, 70, 72);
            cCtx.stroke();
            
            // R√¢u
            cCtx.strokeStyle = '#444444';
            cCtx.lineWidth = 1;
            // R√¢u tr√°i
            cCtx.beginPath();
            cCtx.moveTo(45, 60); cCtx.lineTo(20, 55);
            cCtx.moveTo(45, 65); cCtx.lineTo(20, 65);
            cCtx.moveTo(45, 70); cCtx.lineTo(20, 75);
            cCtx.stroke();
            // R√¢u ph·∫£i
            cCtx.beginPath();
            cCtx.moveTo(83, 60); cCtx.lineTo(108, 55);
            cCtx.moveTo(83, 65); cCtx.lineTo(108, 65);
            cCtx.moveTo(83, 70); cCtx.lineTo(108, 75);
            cCtx.stroke();
            
            // M≈® NOEL
            cCtx.fillStyle = '#D32F2F';
            cCtx.beginPath();
            cCtx.moveTo(35, 30);
            cCtx.lineTo(64, -5);
            cCtx.lineTo(93, 30);
            cCtx.closePath();
            cCtx.fill();
            // Vi·ªÅn m≈© tr·∫Øng
            cCtx.fillStyle = '#FFFFFF';
            cCtx.fillRect(30, 25, 68, 10);
            // Pompom
            cCtx.beginPath();
            cCtx.arc(64, -2, 8, 0, Math.PI * 2);
            cCtx.fill();
            
            // ƒêu√¥i
            cCtx.fillStyle = '#808080';
            cCtx.beginPath();
            cCtx.moveTo(90, 90);
            cCtx.quadraticCurveTo(115, 85, 110, 70);
            cCtx.quadraticCurveTo(105, 80, 88, 85);
            cCtx.closePath();
            cCtx.fill();
            
            const catTex = new THREE.CanvasTexture(catCanvas);
            const catMat = new THREE.SpriteMaterial({ map: catTex, transparent: true });
            catMesh = new THREE.Sprite(catMat);
            catMesh.scale.set(12, 12, 1);
            scene.add(catMesh);
        }

        function updateParticleGroup(group, type, targetState, speed, handRotY, time) {
            const positions = group.geometry.attributes.position.array;
            const sizes = group.geometry.attributes.size.array;
            const colors = group.geometry.attributes.color.array;
            const phases = group.geometry.userData.phases;
            const baseColor = group.geometry.userData.baseColor;
            const baseSize = group.geometry.userData.baseSize;
            
            const targetKey = (targetState === 'TREE') ? 'tree' : (targetState === 'HEART' ? 'heart' : 'explode');
            const targets = group.geometry.userData[(targetState === 'PHOTO' || targetState === 'ONE_FINGER' || targetState === 'TWO_FINGERS') ? 'explode' : targetKey];

            for(let i=0; i<positions.length; i++) {
                positions[i] += (targets[i] - positions[i]) * speed;
            }
            group.geometry.attributes.position.needsUpdate = true;
            
            const count = positions.length / 3;
            
            if (targetState === 'TREE') {
                group.rotation.y += 0.003;
                
                for(let i=0; i<count; i++) {
                    sizes[i] = baseSize;
                    let brightness = 1.0;
                    if(type === 'red') {
                        brightness = 0.5 + 0.5 * Math.sin(time * 3 + phases[i]);
                    } else if(type === 'gold') {
                        brightness = 0.8 + 0.4 * Math.sin(time * 10 + phases[i]);
                    }
                    colors[i*3]   = baseColor.r * brightness;
                    colors[i*3+1] = baseColor.g * brightness;
                    colors[i*3+2] = baseColor.b * brightness;
                }
                group.geometry.attributes.color.needsUpdate = true;
                group.geometry.attributes.size.needsUpdate = true;

            } else if (targetState === 'HEART' || targetState === 'ONE_FINGER' || targetState === 'TWO_FINGERS') {
                group.rotation.y = 0;
                const beatScale = 1 + Math.abs(Math.sin(time * 3)) * 0.15;
                group.scale.set(beatScale, beatScale, beatScale);

                for(let i=0; i<count; i++) {
                    colors[i*3] = baseColor.r; colors[i*3+1] = baseColor.g; colors[i*3+2] = baseColor.b;
                    if (i % 3 === 0) sizes[i] = baseSize;
                    else sizes[i] = 0;
                }
                group.geometry.attributes.color.needsUpdate = true;
                group.geometry.attributes.size.needsUpdate = true;

            } else {
                group.scale.set(1,1,1);
                group.rotation.y += (handRotY - group.rotation.y) * 0.1;

                for(let i=0; i<count; i++) {
                    sizes[i] = baseSize;
                    let brightness = 1.0;
                    if(type === 'gold' || type === 'red') {
                        brightness = 0.8 + 0.5 * Math.sin(time * 12 + phases[i]);
                    }
                    colors[i*3]   = baseColor.r * brightness;
                    colors[i*3+1] = baseColor.g * brightness;
                    colors[i*3+2] = baseColor.b * brightness;
                }
                group.geometry.attributes.size.needsUpdate = true;
                group.geometry.attributes.color.needsUpdate = true;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            const speed = 0.08;
            const handRotY = (handX - 0.5) * 4.0;

            updateParticleGroup(groupGold, 'gold', state, speed, handRotY, time);
            updateParticleGroup(groupRed, 'red', state, speed, handRotY, time);
            updateParticleGroup(groupGift, 'gift', state, speed, handRotY, time);

            photoMeshes.forEach((mesh, i) => {
                if(!mesh.material.map && photoTextures[i]) {
                    mesh.material.map = photoTextures[i]; mesh.material.needsUpdate = true;
                }
            });

            // ==========================================
            // ANIMATE SANTA V√Ä TU·∫¶N L·ªòC
            // ==========================================
            if (state === 'TREE') {
                // Santa ch·∫°y xung quanh c√¢y th√¥ng
                const santaRadius = 45;
                const santaSpeed = 0.5;
                const santaY = -5 + Math.sin(time * 2) * 5;
                santaMesh.position.x = Math.sin(time * santaSpeed) * santaRadius;
                santaMesh.position.z = Math.cos(time * santaSpeed) * santaRadius;
                santaMesh.position.y = santaY;
                santaMesh.visible = true;

                // Tu·∫ßn l·ªôc ch·∫°y ph√≠a tr∆∞·ªõc Santa
                reindeerMeshes.forEach((reindeer, i) => {
                    const offset = (i + 1) * 0.4; // M·ªói con c√°ch nhau m·ªôt ch√∫t
                    const reindeerRadius = 45 + (i - 1) * 5;
                    const reindeerY = -5 + Math.sin(time * 2 + i * 0.5) * 3;
                    reindeer.position.x = Math.sin(time * santaSpeed + offset) * reindeerRadius;
                    reindeer.position.z = Math.cos(time * santaSpeed + offset) * reindeerRadius;
                    reindeer.position.y = reindeerY;
                    reindeer.visible = true;
                });
            } else {
                // ·∫®n Santa v√† tu·∫ßn l·ªôc khi kh√¥ng ·ªü tr·∫°ng th√°i TREE
                santaMesh.visible = false;
                reindeerMeshes.forEach(r => r.visible = false);
            }

            // ==========================================
            // ANIMATE SAO L·∫§P L√ÅNH (lu√¥n hi·ªÉn th·ªã)
            // ==========================================
            if (bgStars) {
                bgStars.rotation.y += 0.0005;
                // L√†m sao l·∫•p l√°nh
                const starSizes = bgStars.geometry.attributes.size.array;
                const starPhases = bgStars.geometry.userData.phases;
                for(let i = 0; i < starSizes.length; i++) {
                    starSizes[i] = 1 + Math.sin(time * 3 + starPhases[i]) * 0.8;
                }
                bgStars.geometry.attributes.size.needsUpdate = true;
            }

            // ==========================================
            // ANIMATE THI√äN TH·∫¶N (bay quanh ph√≠a tr√™n c√¢y)
            // ==========================================
            if (state === 'TREE') {
                angelMeshes.forEach((angel, i) => {
                    const angelRadius = 50;
                    const angelSpeed = 0.3;
                    const offset = i * Math.PI; // ƒê·ªëi di·ªán nhau
                    const angelY = 30 + Math.sin(time * 2 + i) * 5;
                    angel.position.x = Math.sin(time * angelSpeed + offset) * angelRadius;
                    angel.position.z = Math.cos(time * angelSpeed + offset) * angelRadius;
                    angel.position.y = angelY;
                    angel.visible = true;
                });

                // M√®o cute ng·ªìi d∆∞·ªõi g·ªëc c√¢y, l·∫Øc l∆∞
                const catY = -30 + Math.sin(time * 4) * 2;
                const catX = 25 + Math.sin(time * 0.5) * 5;
                catMesh.position.set(catX, catY, 30);
                catMesh.visible = true;
            } else {
                angelMeshes.forEach(a => a.visible = false);
                catMesh.visible = false;
            }

            // Hide all text meshes first
            titleMesh.visible = false;
            starMesh.visible = false;
            loveMesh.visible = false;
            oneFingerMesh.visible = false;
            twoFingersMesh.visible = false;

            if (state === 'TREE') {
                titleMesh.visible = true; starMesh.visible = true;
                titleMesh.scale.lerp(new THREE.Vector3(1,1,1), 0.1);
                starMesh.rotation.z -= 0.02; 
                starMesh.material.opacity = 0.7 + 0.3*Math.sin(time*5);
                photoMeshes.forEach(m => { m.scale.lerp(new THREE.Vector3(0,0,0), 0.1); m.visible = false; });

            } else if (state === 'HEART') {
                loveMesh.visible = true;
                photoMeshes.forEach(m => { m.visible = false; });
                const s = 1 + Math.abs(Math.sin(time*3))*0.1;
                loveMesh.scale.set(s,s,1);

            } else if (state === 'ONE_FINGER') {
                oneFingerMesh.visible = true;
                photoMeshes.forEach(m => { m.scale.lerp(new THREE.Vector3(0,0,0), 0.1); m.visible = false; });
                const s = 1 + Math.abs(Math.sin(time*3))*0.1;
                oneFingerMesh.scale.set(s,s,1);

            } else if (state === 'TWO_FINGERS') {
                twoFingersMesh.visible = true;
                photoMeshes.forEach(m => { m.scale.lerp(new THREE.Vector3(0,0,0), 0.1); m.visible = false; });
                const s = 1 + Math.abs(Math.sin(time*3))*0.1;
                twoFingersMesh.scale.set(s,s,1);

            } else if (state === 'EXPLODE') {
                const baseAngle = groupGold.rotation.y; 
                const angleStep = (Math.PI * 2) / CONFIG.photoCount;
                let bestIdx = 0; let maxZ = -999;
                photoMeshes.forEach((mesh, i) => {
                    mesh.visible = true;
                    const angle = baseAngle + i * angleStep;
                    const x = Math.sin(angle) * CONFIG.photoOrbitRadius;
                    const z = Math.cos(angle) * CONFIG.photoOrbitRadius;
                    const y = Math.sin(time + i) * 3; 
                    mesh.position.lerp(new THREE.Vector3(x, y, z), 0.1);
                    mesh.lookAt(camera.position);
                    if (z > maxZ) { maxZ = z; bestIdx = i; }
                    if (z > 5) { 
                        const ds = 1.0 + (z/CONFIG.photoOrbitRadius)*0.8; 
                        mesh.scale.lerp(new THREE.Vector3(ds, ds, ds), 0.1);
                    } else {
                        mesh.scale.lerp(new THREE.Vector3(0.6, 0.6, 0.6), 0.1);
                    }
                });
                selectedIndex = bestIdx;

            } else if (state === 'PHOTO') {
                photoMeshes.forEach((mesh, i) => {
                    if (i === selectedIndex) {
                        mesh.position.lerp(new THREE.Vector3(0, 0, 60), 0.1);
                        mesh.scale.lerp(new THREE.Vector3(5, 5, 5), 0.1);
                        mesh.lookAt(camera.position); mesh.rotation.z = 0;
                    } else {
                        mesh.scale.lerp(new THREE.Vector3(0,0,0), 0.1);
                    }
                });
            }
            renderer.render(scene, camera);
        }

        // ==========================================
        // FINGER DETECTION HELPER
        // ==========================================
        function isFingerExtended(landmarks, fingerTip, fingerPIP, fingerMCP) {
            // Ng√≥n du·ªói khi tip xa wrist h∆°n PIP
            const wrist = landmarks[0];
            const tipDist = Math.hypot(landmarks[fingerTip].x - wrist.x, landmarks[fingerTip].y - wrist.y);
            const pipDist = Math.hypot(landmarks[fingerPIP].x - wrist.x, landmarks[fingerPIP].y - wrist.y);
            return tipDist > pipDist * 1.1; // Tip ph·∫£i xa h∆°n PIP √≠t nh·∫•t 10%
        }

        function countExtendedFingers(landmarks) {
            // Index: tip=8, PIP=6, MCP=5
            // Middle: tip=12, PIP=10, MCP=9
            // Ring: tip=16, PIP=14, MCP=13
            // Pinky: tip=20, PIP=18, MCP=17
            
            const indexUp = isFingerExtended(landmarks, 8, 6, 5);
            const middleUp = isFingerExtended(landmarks, 12, 10, 9);
            const ringUp = isFingerExtended(landmarks, 16, 14, 13);
            const pinkyUp = isFingerExtended(landmarks, 20, 18, 17);
            
            return {
                index: indexUp,
                middle: middleUp,
                ring: ringUp,
                pinky: pinkyUp,
                count: [indexUp, middleUp, ringUp, pinkyUp].filter(Boolean).length
            };
        }

        function startSystem() {
            document.getElementById('btnStart').style.display = 'none';
            bgMusic.play().catch(e => console.log(e));
            init3D();

            const video = document.getElementsByClassName('input_video')[0];
            const canvas = document.getElementById('camera-preview');
            const ctx = canvas.getContext('2d');
            const debugDiv = document.getElementById('debug');
            
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

            hands.onResults(results => {
                ctx.clearRect(0,0,100,75); ctx.drawImage(results.image, 0, 0, 100, 75);

                // --- Hand Logic ---
                if (results.multiHandLandmarks.length === 2) {
                    const h1 = results.multiHandLandmarks[0]; const h2 = results.multiHandLandmarks[1];
                    const distIndex = Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y);
                    const distThumb = Math.hypot(h1[4].x - h2[4].x, h1[4].y - h2[4].y);
                    if (distIndex < 0.15 && distThumb < 0.15) {
                        state = 'HEART'; return;
                    }
                }

                if(results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    handX = lm[9].x; 
                    
                    // ƒê·∫øm s·ªë ng√≥n du·ªói
                    const fingers = countExtendedFingers(lm);
                    
                    // Debug info (b·ªè comment d√≤ng d∆∞·ªõi ƒë·ªÉ hi·ªÉn th·ªã debug)
                    // debugDiv.style.display = 'block';
                    // debugDiv.innerHTML = `Index: ${fingers.index}<br>Middle: ${fingers.middle}<br>Ring: ${fingers.ring}<br>Pinky: ${fingers.pinky}<br>Count: ${fingers.count}<br>State: ${state}`;
                    
                    // Nh·∫≠n di·ªán c·ª≠ ch·ªâ
                    // 1 ng√≥n: CH·ªà ng√≥n tr·ªè du·ªói
                    if (fingers.index && !fingers.middle && !fingers.ring && !fingers.pinky) {
                        state = 'ONE_FINGER';
                    } 
                    // 2 ng√≥n: ng√≥n tr·ªè V√Ä ng√≥n gi·ªØa du·ªói
                    else if (fingers.index && fingers.middle && !fingers.ring && !fingers.pinky) {
                        state = 'TWO_FINGERS';
                    } 
                    else {
                        // C√°c c·ª≠ ch·ªâ c≈©
                        const tips = [8,12,16,20]; 
                        const wrist = lm[0];
                        let openDist = 0; 
                        tips.forEach(i => openDist += Math.hypot(lm[i].x-wrist.x, lm[i].y-wrist.y));
                        const avgDist = openDist / 4;
                        const pinchDist = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);

                        if (avgDist < 0.25) { 
                            state = 'TREE'; 
                        } else if (pinchDist < 0.05) {
                            state = 'PHOTO'; 
                        } else {
                            state = 'EXPLODE'; 
                        }
                    }
                } else {
                    state = 'TREE'; 
                }
            });

            const cameraUtils = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); }, width: 320, height: 240
            });
            cameraUtils.start();
        }

        window.addEventListener('resize', () => {
            if(camera) { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        });
    </script>
</body>
</html>

